<!DOCTYPE html>
<html>
<head>
  <title></title>
</head>
<body>
  <div id="score-display" style="position: absolute; top: 10px; left: 10px; color: white; font-size: 24px; font-family: Consolas;"></div>

    <button id="restart-button" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 200px; height: 50px; background-color: rgba(128, 128, 128, 0.5); color: white; border: none; display:none;">Restart</button>
</body>
</html>
<style>
  body {
    margin: 0;
  }
</style>

<script
  async
  src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
></script>
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
    }
  }
</script>

<script type="module">
  import * as THREE from 'three'
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js'

  const restartButton = document.getElementById("restart-button");
  restartButton.addEventListener("click", restartGame);
  
  const scene = new THREE.Scene()
  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  )

  const renderer = new THREE.WebGLRenderer()
  renderer.shadowMap.enabled = true;
  renderer.setSize(window.innerWidth, window.innerHeight)
  document.body.appendChild(renderer.domElement)

  const controls = new OrbitControls(camera, renderer.domElement)

  

  function createTree() {
    const tree = new THREE.Group();

    const trunk = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1, 0.1, 3, 8), 
      new THREE.MeshStandardMaterial({ color: "#8B4513" }));

    const leaves = new THREE.Mesh(
      new THREE.SphereGeometry(Math.random() +0.3),  
      new THREE.MeshStandardMaterial({ color: "#008000" }));

    leaves.position.y = 1.5;
    tree.add(trunk);
    tree.add(leaves);
    tree.position.y = Math.random() * -2 - 0.3;
    tree.position.z = -80;
    return tree;

  }

  
  
 function createCar(topcolor, bodycolor, isEnemy = false) {
  const car = new THREE.Group();

  const body = new THREE.Mesh(
    new THREE.BoxGeometry(0.81, 0.5, 1.5),
    new THREE.MeshStandardMaterial({ color: bodycolor })
  );

  const bwheel = new THREE.Mesh(
    new THREE.BoxGeometry(0.9, 0.25, 0.25),
    new THREE.MeshStandardMaterial({ color: "#00000000"})
  );

  const fwheel = new THREE.Mesh(
    new THREE.BoxGeometry(0.9, 0.25, 0.25),
    new THREE.MeshStandardMaterial({ color: "#00000000" })
  );

  const top = new THREE.Mesh(
    new THREE.BoxGeometry(0.81, 0.3, 0.7),
    new THREE.MeshStandardMaterial({ color: topcolor })
  );

  bwheel.position.z = 0.4;
  bwheel.position.y = -0.45;
  fwheel.position.z = -0.4;
  fwheel.position.y = -0.45;
  top.position.y = 0.1;
  if(isEnemy) {
    top.position.z = -0.2;
  }else{
    top.position.z = 0.2;
  }
  body.position.y = -0.3;
  top.castShadow = true;
  body.castShadow = true;

  car.add(fwheel);
  car.add(bwheel);
  car.add(body);
  car.add(top);

  return car;
}

const car = createCar("#ffffffff" , "#00ff00");
scene.add(car);

  class Box extends THREE.Mesh {
    constructor({width,height,depth , color = '#00ff00' , velocity = {x:0 , y:0 , z:0} , position = {x:0 , y:0 , z:0} , iscar=false , isVisible = true , body}) {
      super(
        new THREE.BoxGeometry(width, height, depth) ,
         new THREE.MeshStandardMaterial({ color })
      )
      this.height = height;
      this.width=width;
      this.depth=depth;
      this.position.set(position.x , position.y , position.z)
      this.bottom = this.position.y - this.height/2;
      this.top =  this.position.y + this.height/2;
      this.right = this.position.x + this.width/2;
      this.left = this.position.x - this.width/2;
      this.front = this.position.z + this.depth/2;
      this.back = this.position.z - this.depth/2;
      this.velocity = velocity;
      this.gravity = -0.01;
      this.visible = isVisible;
      this.body = body;

    }

    updateSides() {
      this.right = this.position.x + this.width/2;
      this.left = this.position.x - this.width/2;
      this.bottom = this.position.y - this.height/2;
      this.top =  this.position.y + this.height/2;
      this.front = this.position.z + this.depth/2;
      this.back = this.position.z - this.depth/2;



    }



    update(ground) {
      this.updateSides();
      this.position.x += this.velocity.x;
      this.position.z += this.velocity.z;
      
  
      if(boxColision({box1: this , box2: ground})) {
       
      }else {
       // console.log("Outside the road")
      }

      if(this.body) {
        this.body.position.copy(this.position);
      }

      this.applyGravity(ground);       
    }

    applyGravity(ground) {
      this.velocity.y += this.gravity ;


      if (boxColision({box1: this , box2: ground})) {
        this.velocity.y *= 0.5;
        this.velocity.y = -this.velocity.y;
      }else {
        this.position.y += this.velocity.y;
      }
    }
}

  function boxColision({box1,box2}) {
      const colisionX =  box1.left <= box2.right && box1.right >= box2.left;
      const colisionZ = box1.front >= box2.back && box1.back <= box2.front;
      const colisionY = box1.bottom  + box1.velocity.y <= box2.top && box1.bottom >= box2.bottom;

      return colisionX && colisionZ && colisionY;

     
  }


  const strips = [];
  function generateStrips(posz = 0,color= "#FFFF00" ) {
      const geometry = new THREE.BoxGeometry(0.1 , 1 , 1);  
      const material = new THREE.MeshStandardMaterial({color: "#FFFF00"});
      const strip1 = new THREE.Mesh(geometry,material); 
      const strip2 = new THREE.Mesh(geometry,material);
      const strip3 = new THREE.Mesh(geometry,material);
      scene.add(strip1);
      scene.add(strip2);
      scene.add(strip3);
      

      strips.push(strip1, strip2, strip3);


      strip1.position.y = -2.23;
      strip2.position.y = -2.23;
      strip3.position.y = -2.23;
      strip1.position.x = -1.5;
      strip2.position.x = 0;
      strip3.position.x = 1.5;
      strip1.position.z = posz;
      strip2.position.z = posz;
      strip3.position.z = posz;


  }


  generateStrips(6);
  generateStrips(3);
  generateStrips();
  generateStrips(-3);
  generateStrips(-6);
  generateStrips(-9);
  generateStrips(-12);
  generateStrips(-15);
  generateStrips(-18);
  generateStrips(-21);
  generateStrips(-24);
  generateStrips(-27);
  generateStrips(-30);
  generateStrips(-33);
  generateStrips(-36);



  


  function updateCopycat(original, copycat) {
    copycat.position.copy(original.position);
  // You can also copy other properties like rotation, scale, etc. if needed
} 



  const curbLeft = new Box({width:1 , height:0.5 , depth:100, color:"#ffffffff" , position: {x:-3.5 , y: -1.9 , z: 0}});
  const curbRigth = new Box({width:1 , height:0.5 , depth:100, color:"#ffffffff" , position: {x:3.5 , y: -1.9 , z: 0}});

  curbLeft.castShadow = true;
  scene.add(curbLeft)
  curbRigth.castShadow = true;
  scene.add(curbRigth)



  const cube = new Box({width:1 , height:1 , depth:1.8 , velocity: {x:0 , y:-0.05 , z:0}, isVisible:false});
  cube.castShadow = true;
  scene.add(cube)

  const ground = new Box({width:6 , height:0.5 , depth:100 , color:"#464646" , position: {x:0 , y:-2, z:0}});
  const grassRight = new Box({width:20, height:0.5, depth:100 , color:"#7CFC00" , position: {x:13, y:-2,z:0}});
  const grassLeft = new Box({width:200, height:0.5, depth:100 , color:"#7CFC00" , position: {x:-103, y:-2,z:0}});
  scene.add(grassLeft);
  scene.add(grassRight);
  ground.receiveShadow = true;
  scene.add(ground)


  const light = new THREE.DirectionalLight(0xffffff , 0.5)
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(1, 1, 1); // Set the position of the light
  scene.add(directionalLight);

  // Set up shadows for the directional light (optional)
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 1024;
  directionalLight.shadow.mapSize.height = 1024;
  directionalLight.shadow.camera.near = 0.5;
  directionalLight.shadow.camera.far = 200;
  directionalLight.shadow.camera.left = -50;
  directionalLight.shadow.camera.right = 50;
  directionalLight.shadow.camera.top = 50;
  directionalLight.shadow.camera.bottom = -50;
  //scene.add(light)
  light.position.y = 3;
  light.position.z = 2;
  light.castShadow = true;

  

  const axesHelper = new THREE.AxesHelper( 5 );
  scene.add( axesHelper );
  camera.position.z = 5
  

  const keys = {
    a: {
      pressed:false
    },
    d: {
      pressed:false
    }


  }
  window.addEventListener("keydown" , (event) => {
    switch(event.code) {
      case 'KeyA':
        keys.a.pressed = true;
        break
      case 'KeyD':
        keys.d.pressed= true;
        break
    }
  })

  window.addEventListener("keyup" , (event) => {
    switch(event.code) {
      case 'KeyA':
        keys.a.pressed = false;
        break
      case 'KeyD':
        keys.d.pressed= false;
        break
    }
  })
  

  const enemies = [];
  const trees =  [];
  let frames = 0;
  let spawnrate = 100;
  

  function pickLane() {
    const numbers = [-2.25, -0.75, 0.75, 2.25];
    const randomIndex = Math.floor(Math.random() * numbers.length);
    return numbers[randomIndex];
}


  function pickPlace() {
    const range1 = Math.random() * -10 - 4.5;
    return range1;
  }
  let score = 0;
  

  const treeSpawnRate = 30;

  function restartGame() {
  // Reset any necessary game state here
    location.reload()
    // Remove the button
    restartButton.style.display = "none";
    // Restart the animation loop
    animate();
}

  function animate() {
    score += 1;
    const scoreDisplay = document.getElementById("score-display");
    scoreDisplay.textContent = `Score: ${score}`;
    const animationId = requestAnimationFrame(animate)
    renderer.render(scene, camera)
    cube.update(ground);
    enemies.forEach(enemy=> {
      scene.add(enemy.body);
      enemy.update(ground);
      if(boxColision({box1: enemy,box2:cube})) {
        console.log("end")
        enemies.forEach(enemy=> {
          scene.remove(enemy.body);
          scene.remove(enemy);})
        cancelAnimationFrame(animationId);
        restartButton.style.display = "block";
      }
    })
    frames++;

    curbRigth.update(ground);
    curbLeft.update(ground);
    if(boxColision({box1: cube , box2:curbRigth}) || boxColision({box1: cube , box2:curbLeft})) {
      cancelAnimationFrame(animationId);
    }

    if(animationId % treeSpawnRate === 0) {
      const tree = createTree();
      tree.position.x = pickPlace();
      trees.push(tree);
      scene.add(tree);
    }

    if (animationId % spawnrate === 0) {
      if (spawnrate > 20) {
        spawnrate -= 1;
      }
      const enemyCar = createCar("#00000000", "#ff0000", true);
      const enemy = new Box({
        width: 0.9,
        height: 1,
        depth: 1,
        velocity: { x: 0, y: -0.05, z: 0.2 },
        color: 'red',
        position: { x: pickLane(), y: 0, z: -30 },
        isVisible: false,
        body:enemyCar
      });

      scene.add(enemy); 
      enemies.push(enemy);
    }
   

      trees.forEach(tree => {
        tree.position.z += 0.1; 
    });

       strips.forEach(strip => {
        strip.position.z += 0.1; 
    });
      

    
    const firstStrip = strips[strips.length -1];
    const firstStripPosZ = firstStrip.position.z;
   

    if(firstStripPosZ >= -33) {
      const stripstoRemove = strips.splice(0 , 3);
      stripstoRemove.forEach(strip => {
        scene.remove(strip);
      })
      generateStrips(-36);
    }

    

    enemies.forEach(enemy=> {
      if(enemy.position.z >= 8) {
        scene.remove(enemy.body);
        scene.remove(enemy);
      }
    })
    
    




    cube.velocity.x = 0;
    if (keys.a.pressed) {
      cube.velocity.x = -0.1;
    } else if (keys.d.pressed) {
      cube.velocity.x = 0.1;
    }
    


    updateCopycat(cube, car);
    


















  }

   
  animate()
</script>